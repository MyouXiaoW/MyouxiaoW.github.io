<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦游小王</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-07T12:46:34.134Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>梦游小王</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Router学习</title>
    <link href="http://yoursite.com/2018/06/07/Router%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/06/07/Router学习/</id>
    <published>2018-06-07T12:46:05.000Z</published>
    <updated>2018-06-07T12:46:34.134Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Router学习记录"><a href="#Router学习记录" class="headerlink" title="Router学习记录"></a>Router学习记录</h2><p>在react中使用Router的时候先要在npm中下载这个包并且在js中引用才可以使用它。<br>npm i react-router-dom –save<br>首先要在js文件中引用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import&#123;BrowserRouter as Router&#125; from &quot;react-router-dom&quot;</span><br></pre></td></tr></table></figure></p><p>在index.js中写的形式,必须用<router></router>标签把组件包起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>在index.js引用的组件中需要引用<route>在渲染组件的时候来写出path（路径）,后面可以写component或者是<br>render 也可以是chidren<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path:&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path:&quot;/&quot; render=&#123;()=&gt;&#123;</span><br><span class="line">        return &lt;App /&gt;//这必须是return后面加上组件</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path:&quot;/&quot; children =&#123;App&#125;/&gt;//这里是强制性的，不管path是什么，都强制跳转到children里面的组件</span><br><span class="line"></span><br><span class="line">//path上面可以加上id，在render里面会传入一个props里面有match、location、history等</span><br><span class="line">在Route中如果写了component=&#123;组件&#125;，那么如果要获取URL信息可以去组件中的render函数中的this.props中查找</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/about/:id&quot; render=&#123;(&#123;match:&#123;params&#125;&#125;)=&gt;&#123;</span><br><span class="line">                   switch(params.id)&#123;</span><br><span class="line">                        case &apos;a&apos;:</span><br><span class="line">                            return &lt;About1 /&gt;</span><br><span class="line">                        break;</span><br><span class="line">                        case &apos;b&apos;:</span><br><span class="line">                            return &lt;About2 /&gt;</span><br><span class="line">                        break;</span><br><span class="line">                        case &apos;c&apos;:</span><br><span class="line">                            return &lt;About3 /&gt;</span><br><span class="line">                        break;</span><br><span class="line">                        default:</span><br><span class="line">                            return &lt;About1 /&gt;</span><br><span class="line">                        break;  </span><br><span class="line">                   &#125;    </span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">                </span><br><span class="line">在path前面还可以添加exact 和strict</span><br><span class="line">exact：可以在one后面加上一个/也能打开页面/one/</span><br><span class="line">    /one/one/twotrueno</span><br><span class="line">    /one/one/twofalseyes</span><br><span class="line">    </span><br><span class="line">strict：在后面几个也能打开</span><br><span class="line">    /one//one        no</span><br><span class="line">    /one//one/        yes</span><br><span class="line">    /one//one/two    yes</span><br><span class="line">    </span><br><span class="line">在strict和exact都有的情况下，连一个/都不能加。</span><br><span class="line"></span><br><span class="line">link 组件是一个点击后会跳转的到相应的路径的组件</span><br><span class="line">&lt;link to=&quot;/aa/&quot;&gt;&lt;link /&gt;</span><br><span class="line"></span><br><span class="line">重定向跳转组件to后面是想要重新跳转的路径</span><br><span class="line">&lt;Redirect to=&quot;/aa/&quot; /&gt;</span><br></pre></td></tr></table></figure></route></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;Router学习记录&quot;&gt;&lt;a href=&quot;#Router学习记录&quot; class=&quot;headerlink&quot; title=&quot;Router学习记录&quot;&gt;&lt;/a&gt;Router学习记录&lt;/h2&gt;&lt;p&gt;在react中使用Router的时候先要在npm中下载这个包并且在
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React的学习记录</title>
    <link href="http://yoursite.com/2018/06/05/React%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/06/05/React的学习记录/</id>
    <published>2018-06-05T14:05:24.000Z</published>
    <updated>2018-06-05T14:06:13.417Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="React的学习记录"><a href="#React的学习记录" class="headerlink" title="React的学习记录"></a>React的学习记录</h2><p>如何开始一个react项目呢？<br>在文件夹中打开cmd操作指令输入一下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure></p><p>之后输入以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure></p><hr><p>输入完以上指令后会自动跳转到localhost：3000<br>在使用react的时候要属性jsx语法<br>写法大致如下：</p><p>这两项是为了引入react文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDom from &quot;react-dom&quot;;</span><br></pre></td></tr></table></figure></p><p>这两项是引入了App组件和index的css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import App from &quot;./js/app/app&quot;</span><br><span class="line">import &quot;./css/index.css&quot;</span><br></pre></td></tr></table></figure></p><p>这句话是启动了自动刷新页面功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">    module.hot.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这句话是渲染页面，组件使用的是单标签<app>来使用的,在jsx语法中单标签中必须要用/来结尾而且首字母必须是大写的，render函数的第一个参数是组件，第二个参数是要渲染的位置，第三个参数是渲染之后的一个回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)，</span><br><span class="line">    cb()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></app></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;React的学习记录&quot;&gt;&lt;a href=&quot;#React的学习记录&quot; class=&quot;headerlink&quot; title=&quot;React的学习记录&quot;&gt;&lt;/a&gt;React的学习记录&lt;/h2&gt;&lt;p&gt;如何开始一个react项目呢？&lt;br&gt;在文件夹中打开cmd操作指令
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>今日学习</title>
    <link href="http://yoursite.com/2018/05/31/%E4%BB%8A%E6%97%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/31/今日学习/</id>
    <published>2018-05-31T15:02:27.000Z</published>
    <updated>2018-05-31T15:04:39.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今日的一点小小的总结吧"><a href="#今日的一点小小的总结吧" class="headerlink" title="今日的一点小小的总结吧"></a>今日的一点小小的总结吧</h2><h3 id="ES6里面的面向对象的继承"><a href="#ES6里面的面向对象的继承" class="headerlink" title="ES6里面的面向对象的继承"></a>ES6里面的面向对象的继承</h3><p>在class里面继承之后，子类里面的constructor的this的指向将是父类，必须要在constructor里面加上super()函数才可以，如果传入的参数没有变化的话可以直接在constructor里面直接传入…args参数，并在在constructor里面的super()中传入…args。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class person&#123;</span><br><span class="line">        constructor(name)&#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class child extends person&#123;</span><br><span class="line">        constructor(...arg)&#123;</span><br><span class="line">            super(...arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let  c= new child(&quot;xiaowang&quot;) ;</span><br><span class="line">    console.log(c.name)//xiaowang</span><br></pre></td></tr></table></figure></p><hr><h3 id="Object-defineproperty"><a href="#Object-defineproperty" class="headerlink" title="Object.defineproperty()"></a>Object.defineproperty()</h3><p>object.defineproperty()最后一个参数是一个对象，对象可以放get(),set()两个方法。<br>get()方法会有一个返回值被作为属性值，默认为undefiend。<br>set()方法将接受唯一参数，并将该参数的新值分配给该属性，默认为 undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Archiver() &#123;</span><br><span class="line">  var temperature = null;</span><br><span class="line">  var archive = [];</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(this, &apos;temperature&apos;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">      console.log(&apos;get!&apos;);</span><br><span class="line">      return temperature;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">      temperature = value;</span><br><span class="line">      archive.push(&#123; val: temperature &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  this.getArchive = function() &#123; return archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arc = new Archiver();</span><br><span class="line">arc.temperature; // &apos;get!&apos;</span><br><span class="line">arc.temperature = 11;</span><br><span class="line">arc.temperature = 13;</span><br><span class="line">arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var pattern = &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return &apos;I alway return this string,whatever you have assigned&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function () &#123;</span><br><span class="line">        this.myname = &apos;this is my name string&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function TestDefineSetAndGet() &#123;</span><br><span class="line">    Object.defineProperty(this, &apos;myproperty&apos;, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var instance = new TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = &apos;test&apos;;</span><br><span class="line"></span><br><span class="line">// &apos;I alway return this string,whatever you have assigned&apos;</span><br><span class="line">console.log(instance.myproperty);</span><br><span class="line">// &apos;this is my name string&apos;</span><br><span class="line">console.log(instance.myname);</span><br></pre></td></tr></table></figure><hr><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的this指向，总是会指向上一级。<br>箭头函数的this指向不会被call（），bind（），apply（）改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;今日的一点小小的总结吧&quot;&gt;&lt;a href=&quot;#今日的一点小小的总结吧&quot; class=&quot;headerlink&quot; title=&quot;今日的一点小小的总结吧&quot;&gt;&lt;/a&gt;今日的一点小小的总结吧&lt;/h2&gt;&lt;h3 id=&quot;ES6里面的面向对象的继承&quot;&gt;&lt;a href=&quot;#ES6里
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象的继承和ES6的面向对象扩展</title>
    <link href="http://yoursite.com/2018/05/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES6%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2018/05/30/面向对象的继承和ES6的面向对象扩展/</id>
    <published>2018-05-30T14:14:59.000Z</published>
    <updated>2018-05-30T14:16:45.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的继承和ES6的面向对象扩展"><a href="#面向对象的继承和ES6的面向对象扩展" class="headerlink" title="面向对象的继承和ES6的面向对象扩展"></a>面向对象的继承和ES6的面向对象扩展</h2><h3 id="面向对象的继承"><a href="#面向对象的继承" class="headerlink" title="面向对象的继承"></a>面向对象的继承</h3><p>要实现面向对象的继承瘦小要实现属性继承也就是类式继承：把父类放到子类下面。<br>然后面向对象的继承分为两类，一个是拷贝继承，另一种是原型继承，这都是根据构造函数和实例化对象的特点来完成的。<br>拷贝继承：遍历父类的原型的方法，并赋值给子类的原型。<br>原型继承：创建一个第三方构造函数让其原型等于父类的原型实例化对象这个构造函数实例化对象等于子类原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function Parent (name)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    &#125;；</span><br><span class="line">    </span><br><span class="line">Parent.prototype.say = function()&#123;</span><br><span class="line">    console.log(&quot;哈喽&quot;)</span><br><span class="line">    &#125;；</span><br><span class="line">let p = new Parent；</span><br><span class="line">//类式继承,利用函数的call方法改变this的指向，完成类式继承</span><br><span class="line">function child(name)&#123;</span><br><span class="line">    Parent.call(this,name)</span><br><span class="line">    &#125;</span><br><span class="line">//拷贝继承</span><br><span class="line">let c=new child；</span><br><span class="line">//用 for in  实现浅拷贝,但是也会改变c的constructor的指向，所以需要手动的改回来</span><br><span class="line">for(let attr in Parent.prototype)&#123;</span><br><span class="line">        child.prototype[attr]=Parent.prototype[attr];</span><br><span class="line">        &#125;;</span><br><span class="line">c.constructor=child;</span><br><span class="line">//也可以用assign进行浅拷贝,也要注意实例对象的constructor指向问题</span><br><span class="line">Object（child.prototype，Parent.prototype）；</span><br><span class="line">//也可以用...扩展符，但是不需要改constructor了</span><br><span class="line">//下面是属性继承，首先创建一个新的构造函数,通过这个新的实例化对象找到父级的prototype。</span><br><span class="line">function N()&#123;&#125;</span><br><span class="line">let n = new N;</span><br><span class="line">N.prototype = Parent.prototype;</span><br><span class="line">c.prototype = n;</span><br><span class="line">//还有一种方式</span><br><span class="line">c.prototype = p;</span><br></pre></td></tr></table></figure></p><hr><h3 id="ES6的面向对象的扩展"><a href="#ES6的面向对象的扩展" class="headerlink" title="ES6的面向对象的扩展"></a>ES6的面向对象的扩展</h3><p>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function person()&#123;&#125;===class person&#123;&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">        constructor(name,age)&#123;</span><br><span class="line">        //如果是继承的情况下，在此处加上super()才能改变this的指向</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.age = age;</span><br><span class="line">            // console.log(arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        static say()&#123;</span><br><span class="line">            //静态方法</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        say()&#123;</span><br><span class="line">            //动态方法</span><br><span class="line">            alert(this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runding()&#123;</span><br><span class="line">            //动态方法</span><br><span class="line">            alert(this.name+&apos;会跑!&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>动态方法<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.push(4)</span><br></pre></td></tr></table></figure></p><p>这种可以在实例对象上可以调用的方法</p><p>静态方法<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from()</span><br></pre></td></tr></table></figure></p><p>这种是构造函数上可以调用的方法</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象的继承和ES6的面向对象扩展&quot;&gt;&lt;a href=&quot;#面向对象的继承和ES6的面向对象扩展&quot; class=&quot;headerlink&quot; title=&quot;面向对象的继承和ES6的面向对象扩展&quot;&gt;&lt;/a&gt;面向对象的继承和ES6的面向对象扩展&lt;/h2&gt;&lt;h3 id=&quot;面
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的实际用法</title>
    <link href="http://yoursite.com/2018/05/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/29/面向对象的实际用法/</id>
    <published>2018-05-29T13:55:20.000Z</published>
    <updated>2018-05-29T14:24:39.769Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="面向对象的实际用法"><a href="#面向对象的实际用法" class="headerlink" title="面向对象的实际用法"></a>面向对象的实际用法</h2><p>在学习了面向对象之后总是不知道该怎么用，庸才在什么地方，其实面向对象可以和面向过程想对比较使用，就会发现面向对象的思想会更加的方便。<br>这就好比工人和车床一样，面向过程我们只能根据工人来不断的换车床，调整车床的功能。<br>面向对象使工人和车床分离开搭配，这样搭配工作起来就会更加的简单。</p><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .active&#123;</span><br><span class="line">        background: yellow; </span><br><span class="line">    &#125;</span><br><span class="line">    div&#123;</span><br><span class="line">        width:100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid #000;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .show&#123;</span><br><span class="line">        display: block;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button class=&quot;active&quot;&gt;选项一&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;选项二&lt;/button&gt;</span><br><span class="line">    &lt;button&gt;选项三&lt;/button&gt;</span><br><span class="line">    &lt;div class=&quot;show&quot;&gt;1111111&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;222222222&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;3333333333&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //首先写出构造函数</span><br><span class="line">    function Tab ()&#123;</span><br><span class="line">        this.btns = document.getElementsByTagName(&quot;button&quot;);</span><br><span class="line">        this.divs=document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">        this.event(&quot;onclick&quot;);//在构造函数中调用</span><br><span class="line">    &#125;</span><br><span class="line">    //Tab的原型添加一个函数，这个函数里面有事件</span><br><span class="line">    Tab.prototype.event =function(eventName)&#123;</span><br><span class="line">        let that =this;</span><br><span class="line">        for(i=0;i&lt;this.btns.length;i++)&#123;</span><br><span class="line">            this.btns[i][eventName]=function()&#123;</span><br><span class="line">                for(j=0;j&lt;that.btns.length;j++)&#123;</span><br><span class="line">                    that.btns[j].className=that.divs.className=&quot;&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                this.className=&quot;active&quot;;</span><br><span class="line">                that.divs.className=&quot;show&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let p = new Tab;</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #box&#123;</span><br><span class="line">            width:100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: red;</span><br><span class="line">            position:absolute;</span><br><span class="line">            left:0;</span><br><span class="line">            top:0;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //先写出一个构造函数</span><br><span class="line">    function Drag(id)&#123;</span><br><span class="line">        this.box =document.getElementById(id);</span><br><span class="line">        this.disX=0;</span><br><span class="line">        this.disY=0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Drag.prototype.init = function()&#123;</span><br><span class="line">        this.mousedown()</span><br><span class="line">    &#125;</span><br><span class="line">    //Drag的原型链函数mousedown里面包括着点击事件</span><br><span class="line">    Drag.prototype.mousedown =function()&#123;</span><br><span class="line">        let that = this;</span><br><span class="line">        this.box.addEventListener(&quot;mousedown&quot;,function(ev)&#123;</span><br><span class="line">            that.down(ev);</span><br><span class="line">            function move(ev)&#123;</span><br><span class="line">                that.move(ev);</span><br><span class="line">            &#125;</span><br><span class="line">            function up(ev)&#123;</span><br><span class="line">                that.up(ev,move,up);</span><br><span class="line">            &#125;</span><br><span class="line">            //事件监听绑定原型上的函数</span><br><span class="line">            document.addEventListener(&quot;mousemove&quot;,move);</span><br><span class="line">            document.addEventListener(&quot;mouseup&quot;,up);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Drag.prototype.down=function(ev)&#123;</span><br><span class="line">        this.disX=ev.pageX-this.box.offsetLeft;</span><br><span class="line">        this.disY=ev.pageY-this.box.offsetTop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Drag.prototype.move = function(ev)&#123;</span><br><span class="line">        this.box.style.left = ev.pageX - this.disX + &apos;px&apos;;</span><br><span class="line">        this.box.style.top = ev.pageY - this.disY + &apos;px&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    Drag.prototype.up=function(ev,move,up)&#123;</span><br><span class="line">        document.removeEventListener(&quot;mousemove&quot;,move);</span><br><span class="line">        document.removeEventListener(&quot;mouseup&quot;,up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let p=new Drag(&quot;box&quot;);</span><br><span class="line">    p.init();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;面向对象的实际用法&quot;&gt;&lt;a href=&quot;#面向对象的实际用法&quot; class=&quot;headerlink&quot; title=&quot;面向对象的实际用法&quot;&gt;&lt;/a&gt;面向对象的实际用法&lt;/h2&gt;&lt;p&gt;在学习了面向对象之后总是不知道该怎么用，庸才在什么地方，其实面向对象可以和
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>实例化对象的属性或者方法是谁？</title>
    <link href="http://yoursite.com/2018/05/28/%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95%E6%98%AF%E8%B0%81%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/05/28/实例化对象的属性或者方法是谁？/</id>
    <published>2018-05-28T14:21:53.000Z</published>
    <updated>2018-05-28T14:22:46.959Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="面向对象中如何判实例化对象的属性或者方法是谁？"><a href="#面向对象中如何判实例化对象的属性或者方法是谁？" class="headerlink" title="面向对象中如何判实例化对象的属性或者方法是谁？"></a>面向对象中如何判实例化对象的属性或者方法是谁？</h2><p>&emsp;在学习如何判断实例化对象的属性或者方法是谁的之前我们要先知道一下几点：<br>1、构造函数的原型（prototype）===实例对象的<strong>proto</strong>（这里是三等的全等，而且在浏览器中打印的<strong>proto</strong>是假的不要相信）<br>2、构造函数的原型的方法或者属性只能给它的实例对象用<br>3、prototype这个值是一个对象<br>4、Function是Function构造出来的<br>5、Object也是Function构造出来的<br>6、函数fn既是构造函数也是实例化的对象<br>&emsp;根据以上的几点可以找到实例化对象的属性和方法到底是谁了。</p><hr><p>##一些实例##</p><p>根据下面的代码可以练习找到实例对象的方法或者属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">     this.name = name;</span><br><span class="line">     this.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> Person.prototype.say = function()&#123;</span><br><span class="line">     alert(1);</span><br><span class="line"> &#125;</span><br><span class="line"> Function.prototype.say = function()&#123;</span><br><span class="line">      alert(3);</span><br><span class="line"> &#125;</span><br><span class="line"> Object.prototype.say = function()&#123;</span><br><span class="line">     alert(4);</span><br><span class="line"> &#125;</span><br><span class="line"> Function.say = function()&#123;</span><br><span class="line">     alert(5);</span><br><span class="line"> &#125;</span><br><span class="line"> Person.say = function()&#123;</span><br><span class="line">      alert(2);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> let p = new Person();</span><br><span class="line"> p.say();</span><br><span class="line"> Person.say();</span><br><span class="line"> Function.say();</span><br><span class="line"> Object.say();</span><br></pre></td></tr></table></figure></p><h3 id="总结出来的一些技巧"><a href="#总结出来的一些技巧" class="headerlink" title="总结出来的一些技巧"></a>总结出来的一些技巧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p.say</span><br><span class="line">    1、p.say</span><br><span class="line">    2、Person.prototype.say</span><br><span class="line">    3、Object.prototype.say</span><br><span class="line"></span><br><span class="line">Person.say</span><br><span class="line">    1、Person.say</span><br><span class="line">    2、Person.__proto__ -&gt; Function.prototype</span><br><span class="line">    3、Object.prototype.say</span><br><span class="line"></span><br><span class="line">Function.say</span><br><span class="line">    1、Function.say</span><br><span class="line">    2、Function.__proto__ -&gt; Function.prototype</span><br><span class="line">    3、Object.prototype.say</span><br><span class="line"></span><br><span class="line">Object.say</span><br><span class="line">    1、Object.say</span><br><span class="line">    2、Object.__proto__ -&gt; Function.prototype</span><br><span class="line">    3、Object.prototype.say</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;面向对象中如何判实例化对象的属性或者方法是谁？&quot;&gt;&lt;a href=&quot;#面向对象中如何判实例化对象的属性或者方法是谁？&quot; class=&quot;headerlink&quot; title=&quot;面向对象中如何判实例化对象的属性或者方法是谁？&quot;&gt;&lt;/a&gt;面向对象中如何判实例化对
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>async的学习笔记</title>
    <link href="http://yoursite.com/2018/05/27/async%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/27/async的学习笔记/</id>
    <published>2018-05-27T03:56:46.000Z</published>
    <updated>2018-05-27T03:58:18.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async函数是什么？"><a href="#async函数是什么？" class="headerlink" title="async函数是什么？"></a>async函数是什么？</h3><p>&emsp;async函数就是让异步函数看起来更像是同步函数。</p><p>&emsp;在async函数中会有一个关键字await，await的意思就是在它后面的表达式需要等待执行的结果。</p><p>&emsp;await的后面是promise对象或者也可以是简单的数据类型（被认为是resolve的promise）。</p><p>&emsp;如果await后面的promise是rejected的状态的话，整个async就会被停止，并且抛出错误，可以用try……catch拿到错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function testAwait () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await func1()</span><br><span class="line">        await func2()</span><br><span class="line">        await func3()</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;async的返回值是promise对象或者也可以是简单的数据类型（被认为是resolve的promise）。</p><p>&emsp;在async后面可以通过then（）回调函数，async的return的值就作为参数传入then（）中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function test () &#123;</span><br><span class="line">    return &apos;this is a test async function&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test().then(</span><br><span class="line">    resolveArg =&gt; console.log(resolveArg)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">// this is a test async function</span><br></pre></td></tr></table></figure><hr><h3 id="async函数内部是怎样的？"><a href="#async函数内部是怎样的？" class="headerlink" title="async函数内部是怎样的？"></a>async函数内部是怎样的？</h3><h4 id="await的继发执行"><a href="#await的继发执行" class="headerlink" title="await的继发执行"></a>await的继发执行</h4><p>继发执行就是所有await后面的函数依次执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let num = 0</span><br><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        resolve(num)</span><br><span class="line">        console.log(++num)</span><br><span class="line">    &#125;, ms, &apos;done&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn ()&#123;</span><br><span class="line">  await  timeout(1000)</span><br><span class="line">  await  timeout(2000)</span><br><span class="line">  await timeout(3000)</span><br><span class="line">  return &quot;done1&quot;</span><br><span class="line">&#125;</span><br><span class="line">fn().then((res)=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)//会在6秒后返回</span><br></pre></td></tr></table></figure></p><p>如果async里面中有没有带await的函数，那么就是和这个函数后面的函数进行同步操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function fn ()&#123;</span><br><span class="line">  await  timeout(1000)</span><br><span class="line">    timeout(1000)</span><br><span class="line">  await timeout(1000)</span><br><span class="line">  return &quot;done1&quot;</span><br><span class="line">&#125;</span><br><span class="line">fn().then((res)=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)//在延时2秒后两个函数会同时出来。</span><br></pre></td></tr></table></figure><h4 id="await的并发执行"><a href="#await的并发执行" class="headerlink" title="await的并发执行"></a>await的并发执行</h4><p>并发执行就是所有的一起执行，但是根据Promise最后得出结果的时间给出返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function fn ()&#123;</span><br><span class="line">    let [res1,res2] = await Promise.all([timeout(3000,1),timeout(1000,2)])</span><br><span class="line">    return [res1,res2]</span><br><span class="line">&#125;</span><br><span class="line">fn().then((res)=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)//在1秒时后打印2，3秒时打印1，和[1,2]</span><br></pre></td></tr></table></figure></p><h4 id="await可以截断for循环"><a href="#await可以截断for循环" class="headerlink" title="await可以截断for循环"></a>await可以截断for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function fn (i)&#123;</span><br><span class="line">    return new Promise((res,rej)=&gt;&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            res(i)</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn1()&#123;</span><br><span class="line">    for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">         await fn(i)</span><br><span class="line">    &#125;</span><br><span class="line">    return fn(i)</span><br><span class="line">&#125;</span><br><span class="line">fn1().then (res=&gt;&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;)//打印出1,2,3,4，5,6,7,8,9,10,10，最后的一个是是19行打印出来的。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;async函数是什么？&quot;&gt;&lt;a href=&quot;#async函数是什么？&quot; class=&quot;headerlink&quot; title=&quot;async函数是什么？&quot;&gt;&lt;/a&gt;async函数是什么？&lt;/h3&gt;&lt;p&gt;&amp;emsp;async函数就是让异步函数看起来更像是同步函数。&lt;/p
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="ES7 async" scheme="http://yoursite.com/tags/ES7-async/"/>
    
  </entry>
  
  <entry>
    <title>解构赋值</title>
    <link href="http://yoursite.com/2018/05/24/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2018/05/24/解构赋值/</id>
    <published>2018-05-24T12:31:39.000Z</published>
    <updated>2018-05-24T14:10:03.340Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><p>只要左右两边的模式相同，左边的变量就会被赋予对应的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c]=[1,2,3]</span><br><span class="line"></span><br><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;]</span><br></pre></td></tr></table></figure></p><p>还有另外一种形式:先看右边的，如果右边没有，看等号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [x=y, y=5] = [&apos;a&apos;,7];</span><br><span class="line"></span><br><span class="line">let [x=5, y=5] = [,7]</span><br></pre></td></tr></table></figure><p>右边内容必须是严格的===判断例如undefiend就是没有，null就是有<br>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1] = [undefined];</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">let [x = 1] = [null];</span><br><span class="line">x // null</span><br></pre></td></tr></table></figure></p><h2 id="嵌套模式"><a href="#嵌套模式" class="headerlink" title="嵌套模式"></a>嵌套模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br></pre></td></tr></table></figure><hr><h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><h2 id="对象解构赋值与数组解构赋值的不同"><a href="#对象解构赋值与数组解构赋值的不同" class="headerlink" title="对象解构赋值与数组解构赋值的不同"></a>对象解构赋值与数组解构赋值的不同</h2><p>因为数组的解构赋值是有顺序的，但是对象是无序的，所以对象在使用解构赋值的时候变量必须要跟属性同名才可以。</p><p>如果变量名和属性名不同，那就可以用以下的方式来写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br></pre></td></tr></table></figure></p><h2 id="嵌套模式-1"><a href="#嵌套模式-1" class="headerlink" title="嵌套模式"></a>嵌套模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    &apos;Hello&apos;,</span><br><span class="line">    &#123; y: &apos;World&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br></pre></td></tr></table></figure><p>如果在之前有变量名了，在解构的过程中就可以不用写let了但是需要加上（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">(&#123;x&#125;=&#123;x:1&#125;);</span><br></pre></td></tr></table></figure><p>{x}是一个代码块，会发生语法错误，大括号不在行首就可以避免{x}被解析成代码块</p><p>默认值生效的条件是，对象的属性值严格等于undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x:y=3&#125;=&#123;x:undefined&#125;</span><br><span class="line"></span><br><span class="line">let &#123;x:y=3&#125;=&#123;&#125;</span><br><span class="line"></span><br><span class="line">let &#123;x:y=3&#125;=&#123;x:null&#125;</span><br></pre></td></tr></table></figure><h2 id="实际的应用"><a href="#实际的应用" class="headerlink" title="实际的应用"></a>实际的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let  &#123;left，right，top：Top&#125;=getcompletedStyle（div）</span><br></pre></td></tr></table></figure><p>右边的getcompletedStyle（div）上面有很多属性，可以用解构赋值的方法一次性的获取想要的所有属性值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h1&gt;&lt;h2 id=&quot;匹配模式&quot;&gt;&lt;a href=&quot;#匹配模式&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="ES6 解构赋值" scheme="http://yoursite.com/tags/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>简单的记录promise</title>
    <link href="http://yoursite.com/2018/05/23/%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%B0%E5%BD%95promise/"/>
    <id>http://yoursite.com/2018/05/23/简单的记录promise/</id>
    <published>2018-05-23T14:13:24.000Z</published>
    <updated>2018-05-24T04:34:52.856Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;在学习AJAX的过程中我有很多的不能够理解的地方，例如同步和异步，虽然能有简单的例子给我参考，但是我还是有点模糊，之后又遇到了promise这个ES6中新的属性，我就更加的晕了。但是学习的过程就是这样的，不奢望自己能够一蹴而就，只要自己能够坚持住就满足了。晚上回来之后就开始琢磨promise到底是个什么鬼东西，看了几篇文章，也看了阮一峰的ES6入门，算是对它的方法有了一点点的了解，现在只能说是在这里把它记录下来，方便自己以后更深入的学习。</p><hr><h2 id="promise的三种状态"><a href="#promise的三种状态" class="headerlink" title="promise的三种状态"></a>promise的三种状态</h2><p>&emsp;在看得时候不奢求理解只是想记下来它的三个状态：pending（等待态）、fufiled（成功态）、rejected（失败态）</p><hr><h2 id="promise解决的两个问题"><a href="#promise解决的两个问题" class="headerlink" title="promise解决的两个问题"></a>promise解决的两个问题</h2><p>&emsp;1、回调地狱的问题，解决代码难以维护，第一个函数的输出是第二个函数的输入。<br>&emsp;2、支持多个并发的请示，并获得并发的请求数据。</p><hr><h2 id="promise接收的参数"><a href="#promise接收的参数" class="headerlink" title="promise接收的参数"></a>promise接收的参数</h2><p>&emsp;promise接收一个参数这是阮大神说的，我的理解就是promise只接收一种参数，就是函数，但是要传入两个参数分别是：<br>&emsp;resolve：异步操作执行成功后的回调函数。<br>&emsp;reject：异步操作执行失败后的回调函数。<br>&emsp;这里引用了阮大神的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><hr><h2 id="then的链式操作"><a href="#then的链式操作" class="headerlink" title="then的链式操作"></a>then的链式操作</h2><p>&emsp;then这个链式操作中有两个参数一个是resolve的回调另一个就是reject的回调。当p对象的状态是resolved的时候后调用，另一个是p对象的状态是reject的时候调用。第二个参数可以不写。这两个函数可以接受p传出的值作为参数。</p><hr><h2 id="catch的操作"><a href="#catch的操作" class="headerlink" title="catch的操作"></a>catch的操作</h2><p>&emsp;catch是指定reject的回调，在then的第一个参数resolve中出现异常并不会卡死，才继续带catch中。</p><hr><h2 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h2><p>&emsp;all的用法简单来说就是谁最后走完就以谁为准执行回调。<br>&emsp;all接收一个数组，数组中都是promise的实例。</p><hr><h2 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a>race的用法</h2><p>&emsp;race的用法就是谁跑的快就以谁为准执行回调。<br>&emsp;race也是接收一个数组，数组中都是promise的实例。</p><hr><p>&emsp;以上就是我自己记录的一些关于promise的方法，由于理解不深刻没办法用实例更清楚的说明，但是弄明白之后会在以后的bolg中以实例说明的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&amp;emsp;在学习AJAX的过程中我有很多的不能够理解的地方，例如同步和异步，虽然能有简单的例子给我参考，但是我还是有点模糊，之后又遇到了promise这个ES6中新的属性，我就更加的晕了。但是学习的过程就是这样的，不奢望自己能够一蹴而就，只要自己能够坚持住就满足
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="ES6 promise" scheme="http://yoursite.com/tags/ES6-promise/"/>
    
  </entry>
  
  <entry>
    <title>git上传代码的指令</title>
    <link href="http://yoursite.com/2018/05/22/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/05/22/git上传代码的指令/</id>
    <published>2018-05-22T12:51:59.000Z</published>
    <updated>2018-05-24T04:34:51.432Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先要理解git的工作原理"><a href="#首先要理解git的工作原理" class="headerlink" title="首先要理解git的工作原理"></a>首先要理解git的工作原理</h2><p>   &emsp;git是分布式的工作原理，自己的电脑就是一个服务器，每次写的代码都可以保存到自己的电脑中，并有相对应的版本号，即使文件不小心被删除了，也可以根据版本号进行恢复。</p><p>   &emsp;在git工作的时候其中有三个分区：分别是工作区、暂存区、版本区。</p><h2 id="上传的指令"><a href="#上传的指令" class="headerlink" title="上传的指令"></a>上传的指令</h2><p>   &emsp;在我们写代码的时候就是在工作区进行的操作，每次写入的代码都会保存在工作区里面，但是在不小心删除工作区的文件的时候，文件就会被删除了，为了恢复被删除的文件就需要先把文件上传，分为以下两个步骤：<br>   &emsp;1、把文件由工作区上传到暂存区分为两种方法<br>   &emsp;第一种：上传一个文件到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add  文件的名字</span><br></pre></td></tr></table></figure></p><p>   &emsp;第二种：上传全部的工作区文件到暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure></p><p>   &emsp;2、把文件上传到版本区也是有两种方法<br>   &emsp;第一种是把暂存区所有的文件都上传到版本区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;注释&quot;</span><br></pre></td></tr></table></figure></p><p>   &emsp;第二种是从工作区上传到版本区，但是这种方法的前提是要上传的文件被commit过的才行，有局限性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;注释&quot;</span><br></pre></td></tr></table></figure></p><hr><h2 id="git三个分区内文件内容的比较指令"><a href="#git三个分区内文件内容的比较指令" class="headerlink" title="git三个分区内文件内容的比较指令"></a>git三个分区内文件内容的比较指令</h2><p>&emsp;1、工作区和暂存区的比较指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure></p><p>&emsp;2、暂存区和版本区的比较指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure></p><p>&emsp;3、工作区和版本区的比较指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff master</span><br></pre></td></tr></table></figure></p><p>&emsp;对于以上三个指令，在输入指令后会在git bash上显示两个想比较的分区中同一个文件的改动之处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;首先要理解git的工作原理&quot;&gt;&lt;a href=&quot;#首先要理解git的工作原理&quot; class=&quot;headerlink&quot; title=&quot;首先要理解git的工作原理&quot;&gt;&lt;/a&gt;首先要理解git的工作原理&lt;/h2&gt;&lt;p&gt;   &amp;emsp;git是分布式的工作原理
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git同步数据</title>
    <link href="http://yoursite.com/2018/05/21/git%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/05/21/git同步数据/</id>
    <published>2018-05-21T14:16:52.000Z</published>
    <updated>2018-05-21T14:17:16.404Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="第一种git和github一起操作的"><a href="#第一种git和github一起操作的" class="headerlink" title="第一种git和github一起操作的"></a>第一种git和github一起操作的</h2><h3 id="第一次的操作"><a href="#第一次的操作" class="headerlink" title="第一次的操作"></a>第一次的操作</h3><p>1、新建一个文件夹files<br>2、在github上找到想要下载下来的文件点击右上角的fork<br>3、点击clone or download（绿色的） 复制下网址<br>4、打开文件夹flies，在flies里面运行git bash输入以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://XXXXXXXXXXXXX</span><br></pre></td></tr></table></figure></p><p>输入上面指令后再输入以下指令就可以把文件下载到本地了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p><h3 id="在别人完成了文件的更新之后进行以下操作"><a href="#在别人完成了文件的更新之后进行以下操作" class="headerlink" title="在别人完成了文件的更新之后进行以下操作"></a>在别人完成了文件的更新之后进行以下操作</h3><p>1、在自己的github中找到fork的仓库也就yourname/xxx，把它删除掉，在setting中最下面有删除，输入名称点击删除即可<br>2、再去别人的github中fork想更新的仓库<br>3、回到本地的files里面运行git bash执行一下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p><hr><h2 id="第二种进行的就是git上的指令操作了"><a href="#第二种进行的就是git上的指令操作了" class="headerlink" title="第二种进行的就是git上的指令操作了"></a>第二种进行的就是git上的指令操作了</h2><p>1、新建一个文件夹files<br>2、在新建文件夹中创建环境,运行git bash执行一下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p><p>3、找到自己想更新的仓库点击clone or download（绿色的）<br>4、创建一个远程仓库，在文件夹中运行git bash执行以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add XXX https://xxxx</span><br></pre></td></tr></table></figure></p><p>add后面的XXX就是创建的远程仓库的名字（可以用git remote查看远程仓库有哪些）<br><a href="https://xxxx" target="_blank" rel="noopener">https://xxxx</a>  是clone的网址<br>5、把远程仓库的数据升级，在文件中运行git bash 执行以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote updata XXX</span><br></pre></td></tr></table></figure></p><p>6、从远程的仓库中把数据下载到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull XXX master</span><br></pre></td></tr></table></figure></p><p>在以后更新的时候只需在git bash中执行以下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote update</span><br><span class="line">$ git pull XXX master</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;第一种git和github一起操作的&quot;&gt;&lt;a href=&quot;#第一种git和github一起操作的&quot; class=&quot;headerlink&quot; title=&quot;第一种git和github一起操作的&quot;&gt;&lt;/a&gt;第一种git和github一起操作的&lt;/h2&gt;&lt;h3 
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2018/05/17/%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/05/17/闭包/</id>
    <published>2018-05-17T09:06:16.000Z</published>
    <updated>2018-05-21T14:12:38.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-变量的作用域"><a href="#1-变量的作用域" class="headerlink" title="1.变量的作用域"></a>1.变量的作用域</h2><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量</p><p>函数内部可以直接读取全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var n= 999;</span><br><span class="line"></span><br><span class="line">function f1()&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">f1();//  999</span><br></pre></td></tr></table></figure></p><p>但是函数外部无法读取函数内的局部变量</p><pre><code>function f1(){    var n =999;}alert(n);//error</code></pre><p>注意!   在函数内部声明变量的时候，一定要使用var命令，如果你不用的话，实际上就是声明了一个全局变量</p><pre><code>function f1(){     n=999;}f1();alert(n); //999&lt; !-- more --&gt;</code></pre><hr><h2 id="2-如何从外部读取局部变量"><a href="#2-如何从外部读取局部变量" class="headerlink" title="2.如何从外部读取局部变量"></a>2.如何从外部读取局部变量</h2><p>有的时候我们需要得到函数内部的局部变量，正常情况下是不能实现的，就需要我们在函数的内部再定义一个函数。</p><pre><code>function f1(){    var n=999;    function f2(){        alert(n);  //999    }}</code></pre><p>在上面可以看出，函数f2就包括在函数f1里面，这时f1内部的所有局部变量，对f2都是可见的。但是f2内的局部变量对f1是不可见的。这就是JS中的“链式作用域”，子对象会一级一级的向上寻找所有父对象的变量。所以父对象的所有变量，对子对象都是可见的，反之则不成立。</p><p>既然f2可以读取f1中的变量，那么把f2作为返回值，就可以在f1外部读取它内部的变量。</p><pre><code>function f1(){    var n  =999;    function f2(){        alert (n);    }}var result = f1();result(); //999</code></pre><hr><h2 id="3-闭包的概念"><a href="#3-闭包的概念" class="headerlink" title="3.闭包的概念"></a>3.闭包的概念</h2><p>上一节的代码中的f2函数，就是闭包</p><p>闭包比较简单的理解就是：能够读取其他函数内部变量的函数。</p><p>在JS中只有函数内部的子函数才能够读取局部变量，因此可以把闭包简单的理解成是“定义在一个函数内部的另一个函数”。闭包本质上就是函数内部和函数外部连接起来的一座桥梁。</p><hr><h2 id="4-闭包的用途"><a href="#4-闭包的用途" class="headerlink" title="4.闭包的用途"></a>4.闭包的用途</h2><p>闭包可以用在很多的地方。<br>一、可以读取函数内部的变量<br>二、让这些变量的值始终保持在内存中。</p><pre><code>function f1(){    var n=999;    nAdd=function(){n+=1}    function f2(){        alert(n);    }    return f2;}var result=f1();result(); // 999nAdd();result(); // 1000</code></pre><p>可以看出来在这段函数中，result就是闭包函数f2。它一共运行了两次，第一次的到的值是999，第二次是1000。按照正常情况来说，在f1调用之后它内部的局部变量应该被自动清除，但是第二次能得到1000，是因为f2被赋予给了一个全局变量result，f2始终存再内存中，而f2有依赖于f1，因此f1也始终在内存中，不会再调用结束后，被垃圾回收机制回收。</p><p>在f1中还有一个函数“nAdd=function(){n+=1}”值得注意，这是一个全局变量，前面没有var，nAdd的值也是一个匿名函数，这个匿名函数也是一个闭包，可以在函数的外部对内部的局部变量进行操作。</p><hr><h2 id="5-使用闭包的注意点"><a href="#5-使用闭包的注意点" class="headerlink" title="5.使用闭包的注意点"></a>5.使用闭包的注意点</h2><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><hr><h2 id="6-思考题"><a href="#6-思考题" class="headerlink" title="6.思考题"></a>6.思考题</h2><p>一、</p><pre><code>var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;；    getNameFunc : function(){        return function(){            return this.name;        };    }};alert(object.getNameFunc()());</code></pre><p>alert里面的值this.name,并且在全局作用下调用。this.name相当于指向的是window.name这个属性。答案是this。window</p><p>二、 </p><pre><code>var name = &quot;The Window&quot;;var object = {    name : &quot;My Object&quot;；    getNameFunc : function(){        var that = this;        return function(){            return that.name;        };    }};alert(object.getNameFunc()());</code></pre><p>这种情况下，getNameFunc在它的局部作用中声明了一个变量 that=this。alert在外部调用了这个函数，that.name又在它的父对象中找到了that的值。答案是my object</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-变量的作用域&quot;&gt;&lt;a href=&quot;#1-变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;1.变量的作用域&quot;&gt;&lt;/a&gt;1.变量的作用域&lt;/h2&gt;&lt;p&gt;Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量&lt;/p&gt;
&lt;p&gt;函数内
      
    
    </summary>
    
      <category term="knowledge" scheme="http://yoursite.com/categories/knowledge/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
