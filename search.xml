<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F05%2F17%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1.变量的作用域Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量 函数内部可以直接读取全局变量 var n= 999; function f1(){ alert(n); } f1();// 999 但是函数外部无法读取函数内的局部变量 function f1(){ var n =999; } alert(n);//error 注意! 在函数内部声明变量的时候，一定要使用var命令，如果你不用的话，实际上就是声明了一个全局变量 function f1(){ n=999; } f1(); alert(n); //999 &lt; !-- more --&gt; 2.如何从外部读取局部变量有的时候我们需要得到函数内部的局部变量，正常情况下是不能实现的，就需要我们在函数的内部再定义一个函数。 function f1(){ var n=999; function f2(){ alert(n); //999 } } 在上面可以看出，函数f2就包括在函数f1里面，这时f1内部的所有局部变量，对f2都是可见的。但是f2内的局部变量对f1是不可见的。这就是JS中的“链式作用域”，子对象会一级一级的向上寻找所有父对象的变量。所以父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1中的变量，那么把f2作为返回值，就可以在f1外部读取它内部的变量。 function f1(){ var n =999; function f2(){ alert (n); } } var result = f1(); result(); //999 3.闭包的概念上一节的代码中的f2函数，就是闭包 闭包比较简单的理解就是：能够读取其他函数内部变量的函数。 在JS中只有函数内部的子函数才能够读取局部变量，因此可以把闭包简单的理解成是“定义在一个函数内部的另一个函数”。闭包本质上就是函数内部和函数外部连接起来的一座桥梁。 4.闭包的用途闭包可以用在很多的地方。一、可以读取函数内部的变量二、让这些变量的值始终保持在内存中。 function f1(){ var n=999; nAdd=function(){n+=1} function f2(){ alert(n); } return f2; } var result=f1(); result(); // 999 nAdd(); result(); // 1000 可以看出来在这段函数中，result就是闭包函数f2。它一共运行了两次，第一次的到的值是999，第二次是1000。按照正常情况来说，在f1调用之后它内部的局部变量应该被自动清除，但是第二次能得到1000，是因为f2被赋予给了一个全局变量result，f2始终存再内存中，而f2有依赖于f1，因此f1也始终在内存中，不会再调用结束后，被垃圾回收机制回收。 在f1中还有一个函数“nAdd=function(){n+=1}”值得注意，这是一个全局变量，前面没有var，nAdd的值也是一个匿名函数，这个匿名函数也是一个闭包，可以在函数的外部对内部的局部变量进行操作。 5.使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 6.思考题一、 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;； getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); alert里面的值this.name,并且在全局作用下调用。this.name相当于指向的是window.name这个属性。答案是this。window 二、 var name = &quot;The Window&quot;; var object = { name : &quot;My Object&quot;； getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()()); 这种情况下，getNameFunc在它的局部作用中声明了一个变量 that=this。alert在外部调用了这个函数，that.name又在它的父对象中找到了that的值。答案是my object]]></content>
      <categories>
        <category>knowledge</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
